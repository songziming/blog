<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <title>内存</title>

    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="http://blog.szm.me/memory/">
</head>
<body>
    <header class="header">
    <div class="wrapper">
        <div class="homelink-wrapper">
            <a href="/" class="homelink">
                <strong>Song Ziming's Blog</strong>
            </a>
        </div>
        
        <nav class="nav">
        
            <a href="/archives" class="nav-link">archives</a>
        
            <a href="/about" class="nav-link">about</a>
        
            <a href="https://github.com/songziming/blog" class="nav-link">source</a>
        
        </nav>
    </div>
</header>

    <main class="wrapper">
        <article class="article-block">
    <header class="article-header">
        <h1>内存</h1>
        <p class="article-meta">
            <time datetime="2018-03-03T00:00:00+08:00" itemprop="datePublished">2018-03-03</time>
            
                /
                
                    memory
                
            
        </p>
    </header>
    <main class="article-content">
        <p>参考资料：
- <a href="https://www.techbang.com/posts/18381-from-the-channel-to-address-computer-main-memory-structures-to-understand">圖解RAM結構與原理，系統記憶體的Channel、Chip與Bank</a>
- <a href="https://lwn.net/Articles/250967/">What every programmer should know about memory, Part 1</a></p>

<h3>内存地址到内存条</h3>

<p>应用程序使用虚拟地址，CPU 将虚拟地址转换为物理地址，然后将内存读写动作发给内存控制器（在 PC 上就是北桥芯片）。内存控制器将物理地址转换为总线地址（bus address），将具体的总线设备发送读写指令。如果目标物理地址被映射到内存条中，</p>

<h3>RAM</h3>

<p>现有的 RAM 可以分为两类：SRAM 和 DRAM。SRAM 的全称是 Static Random Access Memory，结构相对复杂，单位体积容量较少，但是存取速度更快，常用作 CPU 内部的寄存器。DRAM 全称 Dynamic Random Access Memory，结构更简单，单位体积容量更大，但是存取速度要比 SRAM 慢，常用作计算机运行内存。</p>

<p>SRAM 和 DRAM 都属于易失性存储介质（volatile memory），也就是断电之后存储在其中的数据都会丢失。DRAM 需要不断地进行再充电（refresh），否则存储的电荷会逐渐消失，因此，“刷新频率”也是现有的内存产品的关键指标之一。</p>

<p>目前常见的商品内存条是 DDR3 或 DDR4，都属于 DRAM 类型。</p>

<h3>DRAM 子系统</h3>

<p>DRAM 内部还有更细化的结构，依据层级大小可以划分为 <code>channel &gt; DIMM &gt; rank &gt; chip &gt; bank &gt; row/column</code>。</p>

<p>channel（通道）可能只有一个，DIMM 通常就是一个内存条包装。rank（路）</p>

<p>最基本的数据单元（storage cell）的结构是二维矩阵，每一行就叫做一个 row，每一列叫做一个 column。此外还有两个特殊的 row，分别是 input-buffer 和 row-buffer，是执行内存写入和读取操作时的缓冲区。</p>

<p>对一个 row/column 矩阵执行的读写操作单位是 bit，也就是对于一个 row/column 矩阵，只能一次读一个 bit，写一个 bit。</p>

<p>但是 CPU 往往一次操作多个 bit，例如对于 64-bit 的 CPU，每次内存读写操作对应 64 个 bit。因此，在</p>

<h3>dmidecode</h3>

<p>dmidecode 是 Linux 系统下的一个命令行工具，能够读取 DMI 表（也有的说法是 SMBIOS 表），通过这个工具，可以获取内存的相关硬件参数。命令语法是</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash">dmidecode -t &lt;<span class="nb">type</span>&gt;
</code></pre></div>
<p>其中 type 字段的合法取值与解释如下：</p>

<table><thead>
<tr>
<th style="text-align: center">type</th>
<th style="text-align: left">information</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: center">0</td>
<td style="text-align: left">BIOS</td>
</tr>
<tr>
<td style="text-align: center">1</td>
<td style="text-align: left">System</td>
</tr>
<tr>
<td style="text-align: center">2</td>
<td style="text-align: left">Base Board</td>
</tr>
<tr>
<td style="text-align: center">3</td>
<td style="text-align: left">Chassis</td>
</tr>
<tr>
<td style="text-align: center">4</td>
<td style="text-align: left">Processor</td>
</tr>
<tr>
<td style="text-align: center">5</td>
<td style="text-align: left">Memory Controller</td>
</tr>
<tr>
<td style="text-align: center">6</td>
<td style="text-align: left">Memory Module</td>
</tr>
<tr>
<td style="text-align: center">7</td>
<td style="text-align: left">Cache</td>
</tr>
<tr>
<td style="text-align: center">8</td>
<td style="text-align: left">Port Connector</td>
</tr>
<tr>
<td style="text-align: center">9</td>
<td style="text-align: left">System Slots</td>
</tr>
<tr>
<td style="text-align: center">10</td>
<td style="text-align: left">On Board Devices</td>
</tr>
<tr>
<td style="text-align: center">11</td>
<td style="text-align: left">OEM Strings</td>
</tr>
<tr>
<td style="text-align: center">12</td>
<td style="text-align: left">System Configuration Options</td>
</tr>
<tr>
<td style="text-align: center">13</td>
<td style="text-align: left">BIOS Language</td>
</tr>
<tr>
<td style="text-align: center">14</td>
<td style="text-align: left">Group Associations</td>
</tr>
<tr>
<td style="text-align: center">15</td>
<td style="text-align: left">System Event Log</td>
</tr>
<tr>
<td style="text-align: center">16</td>
<td style="text-align: left">Physical Memory Array</td>
</tr>
<tr>
<td style="text-align: center">17</td>
<td style="text-align: left">Memory Device</td>
</tr>
<tr>
<td style="text-align: center">18</td>
<td style="text-align: left">32-bit Memory Error</td>
</tr>
<tr>
<td style="text-align: center">19</td>
<td style="text-align: left">Memory Array Mapped Address</td>
</tr>
<tr>
<td style="text-align: center">20</td>
<td style="text-align: left">Memory Device Mapped Address</td>
</tr>
<tr>
<td style="text-align: center">21</td>
<td style="text-align: left">Built-in Pointing Device</td>
</tr>
<tr>
<td style="text-align: center">22</td>
<td style="text-align: left">Portable Battery</td>
</tr>
<tr>
<td style="text-align: center">23</td>
<td style="text-align: left">System Reset</td>
</tr>
<tr>
<td style="text-align: center">24</td>
<td style="text-align: left">Hardware Security</td>
</tr>
<tr>
<td style="text-align: center">25</td>
<td style="text-align: left">System Power Controls</td>
</tr>
<tr>
<td style="text-align: center">26</td>
<td style="text-align: left">Voltage Probe</td>
</tr>
<tr>
<td style="text-align: center">27</td>
<td style="text-align: left">Cooling Device</td>
</tr>
<tr>
<td style="text-align: center">28</td>
<td style="text-align: left">Temperature Probe</td>
</tr>
<tr>
<td style="text-align: center">29</td>
<td style="text-align: left">Electrical Current Probe</td>
</tr>
<tr>
<td style="text-align: center">30</td>
<td style="text-align: left">Out-of-band Remote Access</td>
</tr>
<tr>
<td style="text-align: center">31</td>
<td style="text-align: left">Boot Integrity Services</td>
</tr>
<tr>
<td style="text-align: center">32</td>
<td style="text-align: left">System Boot</td>
</tr>
<tr>
<td style="text-align: center">33</td>
<td style="text-align: left">64-bit Memory Error</td>
</tr>
<tr>
<td style="text-align: center">34</td>
<td style="text-align: left">Management Device</td>
</tr>
<tr>
<td style="text-align: center">35</td>
<td style="text-align: left">Management Device Component</td>
</tr>
<tr>
<td style="text-align: center">36</td>
<td style="text-align: left">Management Device Threshold Data</td>
</tr>
<tr>
<td style="text-align: center">37</td>
<td style="text-align: left">Memory Channel</td>
</tr>
<tr>
<td style="text-align: center">38</td>
<td style="text-align: left">IPMI Device</td>
</tr>
<tr>
<td style="text-align: center">39</td>
<td style="text-align: left">Power Supply</td>
</tr>
</tbody></table>

<p>可见，与内存相关的取值有 5、6、16、17、18、19、20、33、37。</p>

<h3>案例——PALLOC</h3>

<p>论文《PALLOC: DRAM Bank-Aware Memory Allocator for Performance Isolation on Multicore Platforms》。</p>

<p>现有的 OS 都把 DRAM 看作完整的一坨，不考虑内部的细化结构，也就是多少 rank、多少 bank 等一概不考虑。当然，这样开发起来更加容易，而且硬件设计者也在尽力弥合细节的性能影响。但不可否认的是，内部结构确实对性能有影响，既然这样，我们就有理由去追求这些性能提升。</p>

<p>由于内存由多个 bank 组成，在多核环境下，访问不同 bank 会造成性能的差异。如果一个多线程的应用程序，不同的线程运行在不同的 CPU 上，分配内存时，不同的线程使用不同 bank 中的内存，这样可以显著地提升性能。</p>

<p>但是 PALLOC 的目的并不是提升性能，而是增强隔离性和可预测性，适合于嵌入式系统。也就是说，避免因使用相同/不同 bank 而造成的多线程应用性能波动。PALLOC 使 thread 之间的差异变小，但是可能造成单个 thread 的性能小幅下降（因为可用的内存变小了）。</p>

<p>PALLOC 用的是类似内存分区的方式，划定某个 bank 归哪个 CPU 使用之后，这个 bank 就不可能被其他 CPU 使用。</p>

<p>重点：
- 在一个 CPU 上申请的内存不一定就在这个 CPU 上使用。但这并不是 PALLOC 的问题，而是程序设计这个问题。一个“好习惯”就是自己分配自己使用的内存。
- CPU 数量和 bank 数量未必相等，有可能 bank 数量比 CPU 数量少（类似 PCID 的分配）。对于 PALLOC，由于是面向嵌入式系统的，需要设计人员人工指定每个 bank 供哪个 Core 使用（可以在运行时动态更改配置）。
- 文章仅仅考虑了 bank，但是实际上 DRAM 的结构不仅仅有 bank，如果考虑更细的结构（例如 row）是不是性能提升更好？
- bank 的粒度是多大？应该是页大小的整数倍，而且一个 bank 应该映射到连续的物理地址范围。既然需要关心物理地址，那么必然需要编写内核代码。</p>

<h3>案例——High Efficiency General Memory Allocator</h3>

<p>论文《High Efficiency General Memory Allocator》。</p>

<p>主要特点是把软件底层和上层特征统一了起来。内存分配器会根据软件的上层行为调整内存分配策略。</p>

<p>许多软件都实现了自定义的内存分配器，例如在 SSL、LUA 等项目中，都实现了某种类似内存池的机制。但是每个软件都定制一个 allocator 比较麻烦，这篇文章的目的就是开发一个通用的 allocator，能实现更高的性能，也可以实现通用性。</p>

<p>两个假设：
- 如果程序中大量进行内存分配，那么这些内存分配基本上都是在循环中进行的。
- 循环中进行的内存分配通常都是大小相同的。</p>

<p>文章借助编译器对程序进行 instrumentation，利用 LLVM 识别循环和 malloc/free 的调用信息。</p>

    </main>
</article>

<div id="disqus_thread" class="article-block article-comment"></div>
<script type="text/javascript">
var disqus_shortname = 'szm';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']]
    }
});
</script>
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    </main>
    <footer class="footer">
    <div class="wrapper">
        <p>© 2018 <a href="/about">Song Ziming</a></p>
        <p>Generated using <a href="http://jekyllrb.com/">Jekyll</a>.
            Hosted on <a href="https://www.digitalocean.com/?refcode=fa77aca48a33">DigitalOcean</a>.</p>
        <p>Blog source available on <a href="https://www.github.com/songziming/blog">Github</a>.</p>
    </div>
</footer>

    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-73870068-1', 'auto');
    ga('send', 'pageview');
</script>

</body>
</html>
