<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <title>使用 LD_PRELOAD 拦截库函数调用</title>

    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="http://blog.szm.me/hook-library-functions-using-ld_preload/">
</head>
<body>
    <header class="header">
    <div class="wrapper">
        <div class="homelink-wrapper">
            <a href="/" class="homelink">
                <strong>blog.szm.me</strong>
            </a>
        </div>
        
        <nav class="nav">
        
            <a href="/archives" class="nav-link">archives</a>
        
            <a href="/about" class="nav-link">about</a>
        
            <a href="https://github.com/songziming/blog" class="nav-link">source</a>
        
        </nav>
    </div>
</header>

    <main class="wrapper">
        <article class="article-block">
    <header class="article-header">
        <h1>使用 LD_PRELOAD 拦截库函数调用</h1>
        <p class="article-meta">
            <time datetime="2016-02-20T00:00:00+08:00" itemprop="datePublished">2016-02-20</time>
            
                /
                
                    开发
                
            
        </p>
    </header>
    <main class="article-content">
        <p><code>LD_PRELOAD</code> 是 Linux 下一个很有意思的环境变量，通过这个变量，可以在运行程序时强制加载某个动态库，而且是最先加载。通过 <code>LD_PRELOAD</code> 可以非常方便地拦截库函数的调用，而且不需要修改可执行程序。</p>

<h3>拦截 <code>strlen</code></h3>

<p>下面通过一个例子来演示 <code>LD_PRELOAD</code> 拦截 <code>strlen</code> 的方法。首先是一段测试代码：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hello, world!"</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"length is %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>编译生成可执行文件 <code>test</code>，运行，输出 <code>length is 13</code>，没有问题。</p>

<p>下面创建一个 <code>hook.c</code> 文件，里面包含另一个 <code>strlen</code> 实现：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;string.h&gt;
</span><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>这个版本的 <code>strlen</code> 不管输入什么都会返回 4。用下面的命令编译 <code>hook.c</code>：</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>gcc -shared -fPIC hook.c -o hook.so
</code></pre></div>
<p>这样，就生成了 <code>hook.so</code>，其中包含着一个盗版的 <code>strlen</code> 函数，接下来通过下面的命令运行刚才的程序：</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span><span class="nv">LD_PRELOAD</span><span class="o">=</span><span class="nv">$PWD</span>/hook.so ./test
</code></pre></div>
<p>这一次运行程序，输出结果变成了 <code>length is 4</code>，这说明 <code>strlen</code> 函数确实被替换了。</p>

<h3>实现机制</h3>

<p>首先我们分析一下正常的情况。程序中使用了 <code>strlen</code> 函数，而这个函数是 C 语言标准库中提供的，通过 <code>ldd test</code>，我们可以看到 <code>test</code> 文件执行所需的动态库：</p>
<div class="highlight"><pre><code class="language-" data-lang="">linux-vdso.so.1 (0x00007fffda2b4000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1da8a15000)
/lib64/ld-linux-x86-64.so.2 (0x00007f1da8dbe000)
</code></pre></div>
<p>其中 <code>libc.so.6</code> 就是 Linux 下的标准 C 库。一个可执行文件运行的时候，系统会预先加载所需的动态库文件，当可执行文件 <code>test</code> 的镜像加载时，系统会进行动态绑定（也叫重定位），将 <code>test</code> 中对 <code>strlen</code> 的调用与 <code>libc.so.6</code> 中的符号 <code>strlen</code> 关联起来，库函数的调用从而可以正常执行。</p>

<p>环境变量 <code>LD_PRELOAD</code> 的作用就是在加载其他的动态库之前，如果这些库中也定义了某些程序用到的函数，它们就会优先与可执行文件匹配。</p>

<p>因此，<code>hook.so</code> 中定义了 <code>strlen</code>，优先于 <code>libc.so.6</code> 与 <code>test</code> 中的调用匹配，因此后一次运行的时候输出了错误的字符串长度。</p>

<h3>实现功能透明</h3>

<p>通常进行库函数拦截是为了进行监控和统计，功能上要保持一致。因此，在假的库函数中，应该调用真的库函数完成相应功能，例如：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;string.h&gt;
</span><span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">real_strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>现在的问题变成了如何确定 <code>real_strlen</code>，方法就是，通过 Linux 下的动态链接器。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;dlfcn.h&gt;
</span>
<span class="k">typedef</span> <span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">strlen_t</span><span class="p">)(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">strlen_t</span> <span class="n">real_strlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">strlen_t</span><span class="p">)</span> <span class="n">dlsym</span><span class="p">(</span><span class="n">RTLD_NEXT</span><span class="p">,</span> <span class="s">"strlen"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"calling strlen.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">real_strlen</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>在这个版本中，首先使用 <code>dlsym</code> 函数找到 <code>strlen</code> 函数的地址，由于指定了 <code>RTLD_NEXT</code> 参数，因此找到的地址一定是真正的 <code>strlen</code> 函数。另外要注意的是，引用 <code>dlfcn.h</code> 头文件之前需要定义宏 <code>_GNU_SOURCE</code>。</p>

<p>找到真正的 <code>strlen</code> 函数之后，使用 <code>printf</code> 打印一条记录，然后返回真正的 <code>strlen</code> 的结果。</p>

<p>由于这次用到了 Linux 下的动态连接器，需要在编译的时候指定 <code>-ldl</code> 选项：</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>gcc -shared -fPIC -ldl hook.c -o hook.so
</code></pre></div>
<p>再次运行 <code>test</code> 程序，结果如下：</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span><span class="nv">LD_PRELOAD</span><span class="o">=</span><span class="nv">$PWD</span>/hook.so ./test
calling strlen.
length is 13
</code></pre></div>
<h3>优化</h3>

<p>上面的版本仍然有一个不足之处，那就是每次调用 <code>strlen</code> 的时候，都需要定位真正的 <code>strlen</code> 函数，实际上每次查找到的函数地址都是一样的。最适合的是动态库被加载的时候查找真正 <code>strlen</code> 函数的地址并存储下来，之后每次直接调用即可。</p>
<div class="highlight"><pre><code class="language-" data-lang="">#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;dlfcn.h&gt;

typedef size_t (*strlen_t)(const char *str);
strlen_t real_strlen；
size_t strlen(const char *str) {
    printf("calling strlen.\n");
    return real_strlen(str);
}

void lib_init() {
    real_strlen = (strlen_t) dlsym(RTLD_NEXT, "strlen");
}
</code></pre></div>
<p>Linux 下的动态库文件是 ELF 格式，其中 <code>init</code> section 中的函数会在库文件加载的时候自动调用，而要让一个函数放在 <code>init</code> section 需要用 ld 的 <code>-init</code> 参数。</p>

<p>对于 GCC，可以通过 <code>-Wl</code> 参数指定连接器参数，编译的命令如下：</p>
<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>gcc -shared -fPIC -ldl -Wl,-init,lib_init -o hook.so hook.c
</code></pre></div>
    </main>
</article>

<div id="disqus_thread" class="article-block article-comment"></div>
<script type="text/javascript">
var disqus_shortname = 'szm';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']]
    }
});
</script>
<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    </main>
    <footer class="footer">
    <div class="wrapper">
        <p>© 2018 <a href="/about">Song Ziming</a></p>
        <p>Generated using <a href="http://jekyllrb.com/">Jekyll</a>.
            Hosted on <a href="https://www.digitalocean.com/?refcode=fa77aca48a33">DigitalOcean</a>.</p>
        <p>Blog source available on <a href="https://www.github.com/songziming/blog">Github</a>.</p>
    </div>
</footer>

    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-73870068-1', 'auto');
    ga('send', 'pageview');
</script>

</body>
</html>
