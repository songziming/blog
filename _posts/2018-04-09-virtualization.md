---
title: "虚拟化技术介绍"
category: "技术"
published: false
---

> Virtualization v.s. Container

## 虚拟化（Virtualization）

虚拟机管理软件往往被称为 Hypervisor，两种实现方式分别称作 type-1 hypervisor 和 type-2 hypervisor。

type-1 hypervisor 是直接在硬件的基础上实现，hypervisor 本身就是 OS，guest OS 直接运行在这个 hypervisor OS 之上。这类的 hypervisor 有 Xen、KVM 等。

type-2 hypervisor 则是在现有操作系统之上，以软件或者中间件的形式实现的 hypervisor。常用的桌面级虚拟化软件，例如 vmware、virtualbox 等，都属于这类。

虚拟化技术最初是面向服务器（main frame）的，因为人们发现，服务器对硬件的利用效率是很低的，因此将多个实例运行在一个硬件之上，虽然降低了OS的运行效率，但是总体上可以增加对硬件的利用效率。

虚拟化技术中，几个需要考虑的点：
- CPU 虚拟化
- 网络虚拟化
- 存储虚拟化
- IO 虚拟化
- 配置/管理

## 虚拟化 vs 容器（Containerization）

二者的目的类似，都是进行隔离。然而容器是一种轻量级的隔离，不同的容器共用同一个 OS 内核，而不像虚拟化一样，每个虚拟机都有一个单独的内核。

#### UniKernel

由于容器技术必须使用相同的内核，这就对应用环境有了限制。虚拟机中运行的是完整的 OS，因此任何类型的 OS 都可以运行。为了解决这个问题，人们提出了 Unikernel。

UniKernel 是一种轻量级的，专用于容器的 OS。一般来说，OS 的作用是支持多个进程的运行，但是 UniKernel 只能运行一个进程，也就是只能够有一个地址空间（这也是名称里面 Uni 的原因）。

UniKernel 只能有一个地址空间，因此许多标准的 OS 操作是不支持的，例如 fork、创建子进程等。UniKernel 往往是以库的形式提供的，提供某一种编程语言的运行环境。

> linking existing applications that rely on the Linux syscall API to Mini-OS is fairly cumbersome and requires a lot of expert time.

所以说，UniKernel不是用来运行现有应用程序的。


## 嵌入式虚拟化技术

虚拟化最开始应用在服务器和桌面领域，但是在嵌入式设备上使用的较少。的确，嵌入式设备往往性能比较差，在这种设备上面再运行一个虚拟机，会导致性能进一步下降。但是，硬件性能的上升，以及物联网的兴起，让嵌入式虚拟化成为了主流。在嵌入式设备上搞虚拟化，要考虑到很多约束。例如受限的内存和存储、实时性要求。或者，也可以在嵌入式平台上实现一套容器。

嵌入式虚拟化/容器与通用的虚拟化/容器具有很多的区别，其中一个便是目的。在服务器上使用虚拟化和容器技术，主要是为了支持多个虚拟服务器，运行现有的应用软件。但是在嵌入式平台上，一般运行的不是现有的软件，而是定制的，因此嵌入式虚拟化主要目的是安全性。

既然目标是安全性，而且基本上软件都是临时开发的，那么 UniKenrel 这种方式就比较合适。由于 UniKernel 通常是和某一种编程语言绑定的，相当于提供了一种开发和运行环境。而且，在服务器上通常要运行多个进程，进程之间要进行地址空间隔离；而嵌入式平台上如果要运行多任务，通常是多个线程（task），相互之间没有地址空间隔离，因此可以用 UniKernel 实现。

#### Why embedded virtualization

为什么要在嵌入式平台上实现容器/虚拟化？这是必须要回答的问题。

在论文《The Role of Virtualization in Embedded Systems》中，对这个问题进行了分析。

首先来看一下，通用的虚拟化技术有哪些好处：
- 某些软件/系统是分布式的，需要运行在多个系统中（例如 Hadoop、Spark），如果想要在一台计算机上运行这样的软件，那么就需要虚拟化，创建多个虚拟机。
- 实现负载均衡。如果有多个物理机器支持运行虚拟机，那么可以在多个物理节点之间迁移虚拟机，创建新的虚拟机时，也可以选择在负载最低物理节点上创建新虚拟机。
- 节能。这一点和负载均衡正好相反，我们可以把某一个物理节点上运行的所有虚拟机都迁移走，这样这台物理机器之上就可以关机，以节省电能。
- 虚拟机可以对某些重要的服务提供防火墙保护，还可以在各个虚拟机之间实现资源隔离。
- 可以运行多种操作系统，因为某些软件只能在特定OS上运行，如果我们要同时运行这些软件，那么只能依靠虚拟机运行多个OS，并在这些虚拟OS里面运行应用程序。
- 如果是轻量级容器（如 Docker），主要的作用是解决依赖问题，快速创建/删除。

在大部分现有应用中，虚拟机上运行的都是相同的 guest OS（或者是类似的 OS）。
虚拟机之间如果要通信，就像两个物理机器通信一样，使用网络接口。

然后我们再来看一下嵌入式系统的特点，以及在嵌入式平台上实现虚拟化的好处。

1. 传统上，嵌入式设备是性能受限的，功能单一，且封闭的软件系统。但是现在，嵌入式设备也越来越多地融入了通用OS的特点。例如智能手机，这是典型的嵌入式设备，却更像是一个通用的计算机。手机上运行的软件也不再完全是定制的，例如已经有了移动版的Safari、Chrome等。因此，在嵌入式设备上使用虚拟化的一个目的，就是让实时程序和分时程序共存：在虚拟机中同时运行 RTOS 和 GPOS。

2. 另外一个目的，就是追求安全。嵌入式设备的软件生态越来越开放，软件不再全是厂商开发的，系统面临的风险也越来越高。嵌入式平台上的虚拟机能够有效隔离，将软件失效的故障限制在虚拟机之内。

3. 最后一个好处，就是让开发者可以直接发布系统，而不单纯是发布一个软件。因为现在的软件系统已经很复杂了，能不能正常工作，不仅取决于软件本身，还与运行环境和配置选项有关。如果开发者可以把软件和运行环境打包，一同发布，就可以保证能够正常运行，省去配置的麻烦。

除了有上面这些好处，嵌入式平台上的虚拟化还面临着许多困难与制约。

首先，虚拟化意味着严格的隔离。然而在嵌入式平台上，软件系统是高度集成的，各个子系统需要相互协作才能正常运行，隔离不适合嵌入式。如果要强行隔离各个子系统，那么必须提供一种高效的虚拟机间通信机制。

其次，高度集成的软件系统需要统一进行调度，然而对于虚拟机，vmm 首先调度虚拟机，虚拟机内部 guest os 的调度器再调度内部的任务。不容易实现整体的分优先级调度机制。

和调度类似，还有能耗控制的问题。能耗也是要看整体的，而虚拟化隔离的性质，导致单个的 guest os 无法影响总体的功耗。

此外，嵌入式领域最大的问题，其实是软件的复杂度爆炸式增长，已经影响到了设备鲁棒性和安全性。虽然说限制故障的影响范围是一个正确的方法，但虚拟机提供的限制粒度太大，不能够实现细粒度的限制。毕竟，一个虚拟机就是一套完整的OS。

最后，逐渐凸显出来的一个问题，就是信息流控制。目前的嵌入式设备已经不再是单用户的了，例如智能手机，它的用户就包括机主本人、通信服务提供商（移动/联通）、第三方的服务提供商。通常，不同的用户之间彼此不信任，因此，需要一种访问控制机制。

#### 理想的嵌入式虚拟化是什么样的

能够实现组件之间的严格隔离，故障限制在容器的范围之内。

能够向传统虚拟机一样，运行未经过更改的 guest OS，以及未修改定制的应用程序。

对于实时子系统，能够保持实时性和高响应。

提供虚拟机之间的高速数据通信机制，低延迟、高带宽。

- - -

Intel SGX (Software Guard Extensions) (paper from OSDI 16)

TCB -- Trusted Computing Base

所谓 TCB，就是一段被信任的代码。通常为了追求更高的安全性，应该让 TCB 尽量地小。

- - -

## Intel Virtual Machine Extension

引入了两种新的操作模式：
- VMX root operation，VMM（monitor）运行在这种模式之下
- VMX non-root operation，guest os 运行在这种模式之下

VMX 引入了一套新的指令，这些指令只能在 root 模式下运行。另外，VMX 还改变了 non-root 下一些指令的原有行为，使得 VMM 可以管理 guest os。

指令 vmxon/vmxoff 用来启用和禁用 VMX。启用了 VMX 之后，VMM 可以通过 vmlaunch/vmresume 来切换到 guest os 中执行，将控制权转交给 guest os。guest os 也可以将控制权交还给 VMM。

关键是什么情况下会产生 VM Exit，控制权由 guest 交还给 VMM。大致有这几种情况：
- 读写控制寄存器，例如 gdtr、idtr、cr0、cr3 等
- 发生异常、triple fault、外部硬件中断
- VMX-preemption timer

- - -

## Xen

Xen 是一种 type-1 虚拟化技术，可以在没有特殊硬件支持的平台上运行，例如 Core2 之前的 x86 处理器。但是，相应的 guestOS 必须进行显示的修改，才能运行在 Xen 之上。这是因为 Xen 出现的比较早，论文在 2003 年就已经发表，那时候 x86 处理器还没有加入虚拟化的硬件支持。

这种修改guestOS以实现虚拟化的机制叫做 para-virtualization，正是 Xen 在 x86 硬件上采用的方案。

Xen 使用两个关键机制实现客户机和管理器之间的互动。客户机可以发起一个 hypercall 来调用 Xen 的服务（例如更新页表），就像普通的进程执行系统调用一样。管理器则可以通过 Events 来实现到客户机的异步消息通信。

#### CPU Scheduling

虚拟机首先要做的，就是对 CPU 进行虚拟化。这里不能像分区OS一样，为每个 guest OS 指定固定的时间窗，因为 guest OS 中的许多子系统对时间的要求是很高的。在一个分区OS中，开发者知道自己的程序会运行在一个分区中，知道这个分区的时间片有多长，因此他可以在设计程序的时候就予以考虑。但是虚拟机不同，guestOS 不应该知道自己运行在虚拟化环境中，因此如果某个 guest os 设置了一个定时器，那么这个定时器就必须要在制定的时候触发。

Xen 使用的是一种叫做 BVT（Borrowed Virtual Time）调度算法，这种算法能够支持实时任务到通用任务的多种程序类型。