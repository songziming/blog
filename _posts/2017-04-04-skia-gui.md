---
title: "Skia 绘图"
category: "开发"
published: false
---

### 文字

显示文字看起来挺简单，但实际上水很深。

首先说明字体（Font）和字型（Typeface）这两个概念：
- 字体（Font）是若干图元（Glyph）的集合，每个图元（Glyph）描述了一个特定的字符显示成什么样子。可以用位图描述，也可以用矢量图形描述。
- 字型（Typeface）也叫字体家族（Font-family），是一系列字体的集合。这些字体通常具有类似的风格，但具有不同的Weight、Slant，如斜体、粗体。

与字体的有两个概念：
- Font Fallback：当软件制定的某个字体在系统上缺失时，FontManager自动选择合适的其他字体替代。
- Font Substitute：当前字体缺少某些图元（Glyph），因此为了显示这些Glyph，需要使用其他字体（secondary font）。

实现一个Font Fallback逻辑并不容易，因为需要定量地度量字体之间的相似程度。许多软件中，都使用了名称类似FontManager的类实现包括Font Fallback在内的功能。Skia中包含了SkFontMgr类，因此自带了Font Fallback功能。在创建SkTypeface对象时，使用SkTypeface::MakeFromName函数，Skia会根据用户指定的字型选择系统安装的字型使用。

一般来说，用一个绘图函数显示一行文本，只能一次使用一个函数。因此，当文本中包含两种不同的Script，默认字体不能覆盖所有的字符，这时候就需要用另外的字体渲染默认字体缺失的部分。

目前采用的方法是，通过Skia库的`SkTypeface::MakeFromName`函数创建字体，然后调用`openStream`函数获得字体文件的原始内容，从而创建HarfBuzz的字体类型`hb_font_t`的对象。
现在有了Skia的字体，以及Harfbuzz的字体。接下来创建harfbuzz的buffer对象，向buffer添加文本，使用准备好的harbuzz字体对buffer中的文本进行布局。布局之后获得info和pos两个数组。
上面的步骤，分别对默认字体和被选字体操作一遍，然后逐个字符地检查，如果默认字体布局结果中，codepoint为0，说明默认字体缺少这个Glyph，使用被选字体替代。

创建备选字体的时候，可以使用`SkTypeface::MakeDefault`函数，避免备选字体也没有图元的情况。

```
#include <hb.h>
#include <hb-ft.h>

hb_buffer_t *buf = hb_buffer_create();
hb_buffer_add_utf8(buf, text, strlen(text), 0, strlen(text));
hb_buffer_guess_segment_properties(buf);

FT_Face face;
FT_New_Face(ft_library, font_path, index, &face);
hb_font_t *font = hb_ft_font_create(face);
hb_shape(font, buf, NULL, 0);

int glyph_count;
hb_glyph_info_t *glyph_info    = hb_buffer_get_glyph_infos(buf, &glyph_count);
hb_glyph_position_t *glyph_pos = hb_buffer_get_glyph_positions(buf, &glyph_count);

for (i = 0; i < glyph_count; ++i) {
    glyphid = glyph_info[i].codepoint;
    x_offset = glyph_pos[i].x_offset / 64.0;
    y_offset = glyph_pos[i].y_offset / 64.0;
    x_advance = glyph_pos[i].x_advance / 64.0;
    y_advance = glyph_pos[i].y_advance / 64.0;
    draw_glyph(glyphid, cursor_x + x_offset, cursor_y + y_offset);
    cursor_x += x_advance;
    cursor_y += y_advance;
}

hb_buffer_destroy(buf);
hb_font_destroy(font);
```

要显示一段文本，需要按顺序做这些事情：

[ref](https://chromium.googlesource.com/chromium/blink/+/master/Source/platform/fonts/shaping/HarfBuzzShaper.cpp).

1. 创建一个buffer，向buffer添加将要显示的内容（utf16）
2. 准备字体，使用这个字体对buffer进行布局（shaping）
3. 获取布局之后的info和pos数组，每个Glyph对应其中的一个元素，根据这两个数组的内容将codepoint加入SkTextBlob中。

如何实现Font Fallback?

浏览器可以用CSS实现任意多级的Font Fallback，对于普通的GUI程序，通常两级就足够了。
对于比较固定的文本，例如Label，可以创建两个buffer，准备两个字体，分别使用这两个不同的字体进行布局（primary font and secondary font）。
相当于同时用两种字体显示相同的内容

关于字体：baseline
使用hb_font_get_h_extents()函数获得字体的参数：ascent、descent、linegap
可以计算出基线上方的高度和下方的高度。

在许多文本控件中，由于一段文字中包含不同的script，使用不同的字体，计算出的ascent+linegap和descent各不相同，导致中英字符高度不等。
对于这个问题，可以强制规定以primary font的尺寸信息为准，

### Aura

[link](https://chromium.googlesource.com/chromium/chromium/+/master/ui/aura).

Google Aura是Chromium下的一个子项目，目前已经下马。但是代码仍然保留。

Aura的目的是实现一套完整的UI Stack。

### Quick Chrome UI Implementation Backgrounder

[https://www.chromium.org/developers/design-documents/aura-desktop-window-manager]()

Chrome UI for Chrome on Windows and Chrome OS is built using the Views UI framework that lives in src/views. The contents of a window is constructed from a hierarchy of views. View subclasses allow for implementation of various controls and components, like buttons and toolbars. Traditionally Chrome has used a mix of hand-rolled controls for aspects of its user interface where a custom look is desired, such as the browser toolbar and tabstrip, and native controls provided by the host platform where a more conventional look is desired, such as in dialog boxes and menus. When run on Windows, the Win32 API provides for native controls in the form of HWNDs, and on ChromeOS, the Gtk toolkit is used to provide native controls.

A view hierarchy is hosted within a Widget. A Widget is a cross-platform type, and relies on a NativeWidget implementation that is specific to each host environment to perform some duties. The NativeWidget implementation is actually the connection to the host environment. For example, on Windows a NativeWidgetWin wraps a HWND (via the WindowImpl class), receives Windows messages for event handling, painting, and other tasks. In the Gtk world, a NativeWidgetGtk wraps a GtkWidget and responds to signals. The NativeWidget is responsible for translating platform-specific notifications into cross platform views::Events and other types that the rest of Views code can respond to in a platform-independent fashion.

The Chrome UI was originally written for Windows, and so despite the relatively platform-neutral nature of the View hierarchy and much of the views code, Win32-isms did creep in. The philosophy on the Chrome team has always been "let not the perfect be the enemy of the good," so pathways to shorter-term success have been emphasized. The Mac and Desktop-Linux ports of Chrome pursued a different strategy for UI, more aggressively using the native toolkits offered on those platforms (Cocoa and Gtk), so at the start of the Chrome OS project there was still some considerable Win32 influence in Views code. Many of those Win32-isms have been augmented by ifdef'ed Gtkisms.

The reliance on platform widget systems has posed a problem though in that it prevents hardware acceleration of elements of the UI and arbitrary transformation of UI controls. The platform native frameworks are also peculiar in a number of ways, sharing constraints that are not relevant to desktop Chrome or Chrome OS. Before long a desire to eradicate our usage of them grew strong enough to begin work on doing so. An effort was spun up spanning several teams to start by removing Gtk usage in the Views frontend code. This has become one of the major sub-projects required for the Aura work described here.
