要不是写操作系统，估计真的不会涉及到这个。一般的应用程序，内存布局都是标准的，但是操作系统内核则必须精确定义在内存中的布局。

使用 ELF 格式非常方便，但是单纯使用 LD 工具生成的 ELF 往往有过多没用的 section。而对于 OS 内核，我们希望其中的无用信息越少越好。

另一种折衷方案就是，首先生成 ELF 格式的镜像，然后使用 objcopy 工具将其转换为纯二进制格式。objcopy 原本是用来在不同可执行文件格式之间进行转换的，但同样可以生成纯二进制格式。这种格式相当于程序的转储状态，即内存中加载的相对位置。

LD 脚本中，变量 `.` 的行为似乎有些奇怪。因此在 LDS 文件中，最好不使用位置计数器 `.`，而用函数获取前一个 section 的地址和长度并计算出这一个 section 的逻辑地址。

在 LDS 中，每个 section 有两个地址，一个是 VMA（Virtual Memory Address），即虚拟地址，section 之内的所有符号参照这个地址进行重定位，另一个是 LMA（Load Memory Address），即物理地址，该 section 就被加载到这个地址的内存中。
对于 binary 格式的镜像，起始无所谓 LMA，各个 section 相对的 LMA 才有影响
