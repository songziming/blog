title: Git 思想
category: default
tags:
- git
- version control
---

几年前接触 Github，纯粹把它当作网盘使用，之后详细了解了 Git 的用法，才开始真正用它来管理版本。现在，不管做任何项目，已经离不开 Git。版本控制作为软件开发过程的一部分，已经成为习惯，哪怕软件只有一个人开发。

### Git is NOT Github

似乎许多人都把 Git 和 Github 混为一谈，实际上，Git 是一个软件，Github 是一个网站；Git 用来控制版本，Github 使用 Git 提供项目托管服务。像 Github 这样的项目托管平台也不唯一，BitBucket、Google Code，以及开源的 Gitorious、GitLab 都能实现类似功能。总之，Git 是核心，Github 使用 Git 提供更多的服务，并提供一个友好的界面，使得用户即使不了解 Git 也可以使用。

然而，不了解 Git，Github 只能当一个网盘。要了解 Git，首先需要明白版本管理的意义。

### 版本管理

Git 作为一个版本管理工具，其首要任务便是管理版本。最简单的版本管理方式，就是手动备份，例如定期将项目源代码文件夹复制一份，依次命名为 `1`、`2`、`3`、`4`，有时候还加上备份的日期以示区别。这样，一旦软件发生不测，可以切换回最近一次的备份，保证开发过程进度能够继续。

最早的版本管理方式就是这样。我相信，在今天，仍有（不少）人用这种手工备份的方式进行版本控制。这种方式虽然无须任何工具的支持，但是非常冗余，即使两个版本之间只改动了几行代码，也要将整份源码完整地复制一份。因此，有人创造了 diff 和 patch 这两个工具，能够自动创建两个文件的区别文件，称为“补丁”，将这个“补丁”作用在原来的版本上，文件就自动转变为新版本。Linus 曾说，早期 Linux 内核的版本控制方式就是“tarballs and patches”。

“Tarballs and patches”的方式仍然非常原始，因为有大量工作需要手工完成，因此现代版本管理工具的一个功能就是自动追踪记录变更。

### 多人协作

版本管理所需考虑的另一个问题，就是如何进行多人协作。“Tarballs and patches”的方式下，开发者通过邮件发送他们的 Patches，其他人据此更新自己的版本。但是，patch 只能作用在特定版本的源码上，因此版本控制工具的另一个任务，就是维持不同版本间的同步。

这里以 SubVersion 为例。SubVersion 是一个集中式的版本管理工具，项目的源代码存放在服务器上，称为主代码仓库（master repo），每个开发者的个人电脑上存有源码的拷贝，称为从代码仓库（slave repo）。如果要贡献代码，必须将自己对源码所作的改动提交到服务器。同时为了避免冲突，同一时刻只有一人提交代码。一旦服务器上的版本更新，所有开发者都需要更新本地代码以保证内容一致。

### 分布式

SubVersion 的集中式设计能够满足大部分软件公司的需求，通常开发者早上更新本地仓库，用一天编写代码，晚上下班前统一提交到服务器，愉快的一天结束。但是，对于开源项目而言，这样集中的管理方式却非常死板。开源项目的开发者通常没有固定工作时间，甚至不在一个时区，不能保证统一更新仓库、提交变更。Git 就是为了解决这个问题而生的，因此 Git 最大的特色，就是其分布式代码仓库的设计。

在 Git 中，不再有集中的代码服务器，代码仓库不再有主从之分，每个代码仓库都是独立的。每个开发者可以将自己的改动推送到任何其他仓库中，也可以从任何仓库获取最新版本。实际应用中，通常有一个服务器存放项目的代码仓库，所有开发这都以这个仓库作为本地仓库的上游仓库。这样，开发者在本地仓库上执行 push 和 pull 操作时，默认于上游仓库交互。但是，各个仓库实际上是独立的，完全可以记录下代码的变更后不提交，或者更改上游仓库，将改动提交到其他地方。

- - -

下面开始介绍 Git 的工作方式。

### 版本、提交

Git 使用快照记录版本内的每个文件。如果文件整体上发生了变更，那么 Git 就将文件的新版本保存一份，如果文件的内容没有发生改变，那么在新版本中只会保存一个指向旧版本中该文件快照的指针。

在 Git 中，一个文件可以处于以下三种状态之一：

- **已提交**，表示文件未更改，或者变更已经安全提交至本地数据库
- **已修改**，表示文件内容发生改变，但是还未提交保存
- **已暂存**，表示文件已修改，但是尚未提交至本地数据库

当一个文件的内容改变时，文件状态由“已提交”变为“已修改”（not staged fot commit），当使用 `git add` 命令添加修改后，文件状态变为“已暂存”（to be committed），使用 `git commit` 提交改动至本地数据库之后，文件状态回到“已提交”。

### 分支、当前分支

每一次的提交，在 Git 中保存为一个提交对象（commit object）。这个提交对象包含指向当前暂存区的指针，以及提交者和 commit log 等相关信息。而 Git 分支实际上就是一个指向提交对象的指针。假设从一个状态开始，对文件进行两种不同方式的修改，分别提交，在 Git 中就会保存两个提交对象。如果存在两个分支，分别指向这两个提交对象，就相当于项目在朝着两个方向前进，这与我们对分支的直观印象一致。

Git 还有一个称为 HEAD 的指针，它指向一个分支。HEAD 指向的分支就是该项目的当前分支，使用 `git checkout` 命令切换分支，实际上是改变了 HEAD 指针的指向。

分支的合并，表面上是将两个分支合并为一个分支，实际上是三方的和并。例如将分支 B 和分支 C 合并，Git 会寻找 B 和 C 的最近共同祖先 A，根据状态 A、B、C 的快照，创建一个新的提交对象，然后将不再需要的分支删除。

### 对象系统

上面的叙述中，多次提到“指针”。这里所说的指针并不是 C 语言中的指针，因为 Git 需要将数据持久化到磁盘。Git 使用了面向对象的设计思想，所有文件、版本、提交，在 Git 内部都用对象表示，这些对象可以持久化，而前面说的“指针”实际上就是对这些对象的引用。Git 使用一个键值对系统管理所有的对象，不管插入什么内容，都会返回一个键值。Git 默认使用 SHA-1 哈希值作为对象的键值，而“指针”就是一个保存有特定 SHA-1 哈希值的文件，这个哈希值指向哪个对象，该指针就指向哪个对象。

### 参考资料

这里仅仅就我所了解的 Git 工作原理进行了介绍，如果需要了解更多，查看在线的 [Pro Git](http://git-scm.com/book/en/v2)（[中文版](http://git-scm.com/book/zh/v1)）是个不错的选择。
