---
title: 操作系统的内存管理
category: "底层"
tags: ["os"]
---

内存管理是操作系统的核心功能之一，实现方式也有很多，本文介绍其中一种方式（基于 Linux，但不完全一样）。

### 层次

内存管理有两个层次，底层是物理内存管理，上层是虚拟内存管理。物理内存管理使用 CPU 的分页机制，实现物理页帧的分配与回收。虚拟内存管理建立在物理内存管理的基础上，实现连续地址的分配与释放。最直观的感受就是，虚拟内存管理提供 `malloc` 和 `free` 接口。

内核层与用户层使用不同的虚拟内存管理器，这是因为内核与应用程序有不一样的性能需求。但是，物理内存管理都是由内核提供的，应用程序通过系统调用向内核请求和释放页。

### 物理页帧分配——伙伴算法

CPU 通过分页机制实现虚拟地址到物理地址的转换。分页机制将虚拟地址空间划分为若干“页面”，将物理地址空间划分为若干“页帧”，通过页表描述虚拟页面到物理页帧的映射关系。虚拟页面必须有对应的物理页帧才可用，因此对物理页帧的管理就是内存管理结构中最底层的组件。

伙伴算法是一个管理物理页帧的高效方法，页帧的分配和释放速度很快。伙伴算法把页帧组织成 Buddy，第 $n$ 阶的 Buddy 就是连续 $2^n$ 个物理页帧。

### 分配

请页时，需要指定所请求页的阶数。例如申请 n 阶的页，则会返回 $2^n$ 个连续的物理页，而且这些物理页的首地址是按 $2^n$ 个页的大小对齐的。

分配了 $2^n$ 个物理页，还需要在位图中设置相应位，所有阶的 buddy 位图都会受到影响。原则上，分配低阶内存块不应破坏高阶内存块的完整性。例如，分配一个 4K 块，应尽可能寻找已经使用一半的 8K 块，因为使用了其中一半的 8K 块已经为不可用状态，用掉其中的另一半不会浪费可用的 8K 块。

### 跳阶

传统 buddy 算法以 2 为底数合并位图。然而，位图可以通过 uint64 同时操作 64 位，因此位图也不需要每隔 2 倍合并一次。

```
buddy[0]:1b	4K
buddy[0]:2b	8K
buddy[0]:4b	16K
buddy[0]:8b	32K
buddy[0]:16b	64K
buddy[0]:32b	128K
buddy[0]:64b	256K
//
buddy[1]:1b	512K
buddy[1]:2b	1M
buddy[1]:4b	2M
buddy[1]:8b	4M
buddy[1]:16b	8M
buddy[1]:32b	16M
buddy[1]:64b	32M
//
buddy[2]:1b	64M
buddy[2]:2b	128M
buddy[2]:4b	256M
buddy[2]:8b	512M
buddy[2]:16b	1G
buddy[2]:32b	2G
buddy[2]:64b	4G
```

用这种方法，就需要一种在位图中寻找连续 n 个 1 的算法，其中 n 是 2 的幂。

不妨设 $n=2^l$（$i<6$），如果把这连续 $n$ 个 1 的范围称作一个块，则一个 $64$ 位无符号整数中一共包含 $2^{6-l}$ 个这样的块，从低位到高位编号为 $b_0, b_1, \cdots, b_{2^{6-l}-1}$。

假设第一个（较低为开始）的全 1 块下标为 $i$，那么之前所有的块都不是全 1 的。因此，给每个块加 1，只有全 1 的块会产生进位。而第 $i$ 块是第一个全 1 的块，因此更低位的块不会产生进位，不会对第 $i$ 块造成影响。这样的结果就是，第一个全 1 的块在加 1 之后变为全零。其他的块加 1 之后没有变为全零。

变全零的另一种解释就是，原来最高位的 1 变成了 0。综合以上条件，如果一个块最高位是 1，加一之后最高位变为 0，就说明这个块是全 1 的。把一个块放到整个 uint64 中，对于那些非全 1 的块，加一的进位不会对后续块造成影响，因此，最终结果只要查看各个块加一前后的最高位，只要有一个位满足要求（加一前为 1，加一后为 0），就说明存在这样的全一块。

代码：

``` c
int find_2_continuous_ones(uint64_t data) {
    if (int x = data & ~(data + 0x5555555555555555UL) & 0xaaaaaaaaaaaaaaaaUL) {
        // trailing zeros: 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25
        return __builtin_ctz(x) & ~1;
    }
    return -1;
}
int find_4_continuous_ones(uint64_t data) {
    if (int x = data & ~(data + 0x1111111111111111UL) & 0x8888888888888888UL) {
        // trailing zeros: 3, 7, 11, 15, 19, 23, 27, 31, 35, 39, 43, 47, 51, 55, 59, 63
        return __builtin_ctz(x) & ~3;
    }
    return -1;
}
int find_8_continuous_ones(uint64_t data) {
    if (int x = data & ~(data + 0x0101010101010101UL) & 0x8080808080808080UL) {
        // trailing zeros: 7, 15, 23, 31, 39, 47, 55, 63
        return __builtin_ctz(x) & ~7;
    }
}
int find_16_continuous_ones(uint64_t data) {
    if (int x = data & ~(data + 0x0001000100010001UL) & 0x8000800080008000UL) {
        // trailing zeros: 15, 31, 47, 63
        return __builtin_ctz(x) & ~15;
    }
}
int find_32_continuous_ones(uint64_t data) {
    if (int x = data & ~(data + 0x0000000100000001UL) & 0x8000000080000000UL) {
        // trailing zeros: 31, 63
        return __builtin_ctz(x) & ~31;
    }
}
```
