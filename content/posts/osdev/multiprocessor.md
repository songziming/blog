---
title: "多核"
---

### 多核的启动

我们的 OS 是用 GRUB 引导的，使用 GRUB 的一个好处就是我们直接进入保护模式，然而在启动多核的时候，我们还是从实模式开始运行。

启动 AP 是通过 BSP 发送 IPI 实现的，IPI 也就是处理器间中断，但是 IPI 不能传参数，因此我们需要想一个另外的办法。

可以使用全局变量。既然我们的 AP 是一个一个启动的，也就是一个 AP 在启动过程中，不会有另一个 CPU 和它竞争，因此可以根据 `cpu_activated` 来确定自己的编号，而且这个编号一定是连续的。

AP 也是要运行 C 代码的，因此需要自己的栈。多个 CPU 肯定不能共用同一个栈，这会让 CPU 上运行的函数出错。但是如果也像 BSP 一样，给 AP 指定一个全局唯一的内核栈用来初始化也不合适。最好的选择就是，让 AP 的初始化过程完全在汇编代码中执行，当它开始执行 C 函数的时候，这个函数就是 AP 上的 IdleTask。

AP 初始化过程中很重要的一个步骤，就是保护模式进入长方式。BSP 有这部分的代码，AP 启动的时候应该复用这部分。但是，BSP 初始化的时候，直接指定了内核栈的位置是 16MB，也就是内核加载位置之前，如果 AP 也执行这段代码，就使用了和 BSP 相同的内核栈。不过有一个办法可以避免问题，那就是让 BSP 首先开始执行任务，这样 BSP 就切换到了任务栈，而那个初始化过程使用的内核栈就空闲下来了，AP 正好可以使用。