---
title: "任务调度"
# kind: "article"
tags: ["sched", "multi-task", "os"]
---

现在已经实现了基本的任务，能够进行两个任务之间的相互切换，接下来需要考虑一下如何进行调度了。

### 任务切换

首先需要明确调度问题的定位。调度本身不是目的，而是实现任务切换过程的一个子问题。因此首先需要明确任务切换有哪些种类，以及哪些因素会导致任务切换。（我们假定这个操作系统是按照任务优先级进行抢占式调度，相同优先级的任务之间采用时间片轮转）

任务切换分为主动和被动两种：

主动切换
: 当一个任务由 ready 状态变为 pend 状态，或者执行 sleep 函数主动进入等待状态，那么这个任务就应该主动让出 CPU，进入 suspend/delayed 状态，让其他的任务使用 CPU 执行。

被动切换
: 当一个任务的时间片用完，或者创建了一个新的更高优先级的任务，或者是一个更高优先级的任务从 suspend 状态恢复为 ready 状态时，系统就需要将当前正在执行的任务挂起，转而去执行队列中的下一个任务（时间片用完的情况），或者执行那个优先级更高的任务。

根据任务切换的发生时间，还可分为两类：

在中断上下文发生任务切换
: 也就是在 ISR、看门狗内部执行。如果我们在中断上下文执行，说明我们在进入中断的时候已经把当前任务的状态保存下来了。

在非中断上下文（即任务上下文）发生任务切换
: 非中断上下文，也就一个任务在正常运行的情况下，发生任务切换。

Wheel 大量参考了实时系统的设计，因此开发过程中，相对 Linux 这类 GPOS，也更加注重实时性。
然而，增强了实时性，可能会导致公平性下降。

### CFS

Linux 下使用 CFS 策略进行调度，这个算法使用红黑树管理进程，每个 CPU 都有一个就绪队列，没有所谓的 global readyq。

由于没有一个全局队列，每创建一个新的任务，都要选择一个CPU，添加到它的就绪队列中，也就是将这个任务分配到一个 CPU。
