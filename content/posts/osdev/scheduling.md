---
title: "任务调度"
# kind: "article"
tags: ["sched", "multi-task", "os"]
---

现在已经实现了基本的任务，能够进行两个任务之间的相互切换，接下来需要考虑一下如何进行调度了。

> 参考：
>
> - [Context Switching on x86 (xv6)](https://samwho.co.uk/blog/2013/06/01/context-switching-on-x86/)
> - [Linux O(1) Scheduler](https://www.ibm.com/developerworks/library/l-scheduler/index.html)
> - [Linux CFS Scheduler](https://www.ibm.com/developerworks/linux/library/l-completely-fair-scheduler/)

### 任务切换

首先需要明确调度问题的定位。调度本身不是目的，而是实现任务切换过程的一个子问题。因此首先需要明确任务切换有哪些种类，以及哪些因素会导致任务切换。（我们假定这个操作系统是按照任务优先级进行抢占式调度，相同优先级的任务之间采用时间片轮转）

任务切换分为主动和被动两种：

主动切换
: 当一个任务由 ready 状态变为 pend 状态，或者执行 sleep 函数主动进入等待状态，那么这个任务就应该主动让出 CPU，进入 suspend/delayed 状态，让其他的任务使用 CPU 执行。

被动切换
: 当一个任务的时间片用完，或者创建了一个新的更高优先级的任务，或者是一个更高优先级的任务从 suspend 状态恢复为 ready 状态时，系统就需要将当前正在执行的任务挂起，转而去执行队列中的下一个任务（时间片用完的情况），或者执行那个优先级更高的任务。

根据任务切换的发生时间，还可分为两类：

在中断上下文发生任务切换
: 也就是在 ISR、看门狗内部执行。如果我们在中断上下文执行，说明我们在进入中断的时候已经把当前任务的状态保存下来了。

在非中断上下文（即任务上下文）发生任务切换
: 非中断上下文，也就一个任务在正常运行的情况下，发生任务切换。这种情况下，当前正在运行的任务还没有保存状态

### 设计目标

我们要设计一种调度策略，那么一个好的调度策略需要满足哪些条件？

- 性能，调度的核心就是选出接下来要运行的任务，需要在常数时间内完成。
- 公平，相同优先级的任务应该运行时长相同，在宏观上来看，任务的平均执行速度应该是一样的。
- 多核，我们要支持多核，那么每个 CPU 上都需要进行调度。为了防止竞争，应该尽量使用 per-cpu var。

### O(1) Scheduler

首先来看一下 Linux 早期的一个调度策略，称作 O(1) 调度，不过这个调度目前已经不在代码中了，因此下面的描述都是基于网上的相关资料。

在 O(1) 之前，调度的时间复杂度是线性的。但是后来 Java 虚拟机的出现，JVM 在执行过程中会创建许多线程，这就使得 JVM 在 Linux 上面执行缓慢。为此开发者提出了能够在常数时间内实现调度的新算法。

O(1) 调度器定义了一个新的数据结构 runqueue，定义了任务的 140 种优先级，其中前 100 个优先级是供实时进程使用的，最后的 40 个优先级供用户态进程使用。每当我们创建一个新的任务，这个任务就被放入对应优先级的那个优先队列的末尾。

一个 runqueue 就是由 140 个优先队列。每个 CPU 拥有两个 runqueue，分别称作 active 和 expired。如果 runqueue 中的所有任务时间片都用完了，我们就交换 active 和 expired 两个 runqueue，同时重新计算每个任务的时间片。

当一个任务用完自己的时间片，这个任务就会从 active runqueue 中移除，放入 expired runqueue 里面。在这个移动的过程中，系统会重新计算时间片和优先级。

什么情况下切换 runqueue？当一个特定优先级的任务全部用完时间片，我们就进行切换，也就是说并非把 runqueue 中的所有任务运行完成。因为 Linux 是支持抢占的，因此如果存在一个高优先级的任务，那么我们就运行高优先级的。

#### 动态优先级

O(1) 调度还实现了动态优先级，也就是运行中的任务优先级是可以变的。如果一个任务是 CPU-bound，它将受到系统的惩罚；如果一个任务是 IO-bound，也就是执行一个阻塞的操作然后进入 PEND 状态，那么这样的任务会得到系统的奖励。奖罚都是通过调整优先级实现的，优先级的增减不超过 5。如何判断一个任务是属于 CPU-bound 还是 IO-bound？可以计算任务执行的时间和等待的时间，也就是说，当任务执行一个 IO 操作并进入阻塞态的时候，我们需要记录进入这个阻塞状态的时间，等接下来回到 ready 状态时，我们才能知道这个任务花了多长时间阻塞。（因为阻塞的时候，CPU 在运行其他任务，因此仅仅统计运行的时间是不够的）

需要说明的是，这种动态优先级不适用于实时任务。也就是只有优先级为后 40 的任务才会调整优先级。

#### SMP 负载均衡

在多核环境下，新创建出来的任务需要放在一个 CPU 上运行，但此时我们无法确定这个任务是长期的还是短期的。因此随着系统运行，各个 CPU 的负载可能会变得不均衡。因此，每隔 200ms，就会有一个处理器检查各个 CPU 上的负载是否平衡，如果不平衡，就把一些任务从高负载的 CPU 上移走，放到低负载的 CPU 上运行。

但是任务的迁移也是有代价的，目标 CPU 的缓存是冷的，因此会给任务的运行速度造成一定影响。

### CFS

貌似 CFS 也是在 Linux 2.6 里面加入的，和 O(1) 非常相似，但是解决了 O(1) 算法不能保证任务公平性的问题。

CFS 使用 virtual-runtime 来表示一个任务运行了多少时间，调度的时候，virtual-runtime 最小的那个任务就是接下来需要运行的。

这里面有一个问题，如果有一个任务处于阻塞状态，那么这个任务是不会使用 CPU 运行的，因此它的 virtual-runtime 也不会增长。这是任务状态切换到了 ready，那么这个任务就成了当前 virtual-runtime 最小的，将会长时间占据 CPU，显然不符合我们的初衷。因此，在任务阻塞的时候，它的 virtual-runtime 也是需要增长的。从另一方面理解，任务阻塞的时候，实际上是不在就绪队列中的，当恢复运行的时候，再次加入到就绪队列。我们需要保证的，就是当一个任务被加入就绪队列时，给它设置一个合适的 virtual-runtime 值。

CFS 将就绪状态的任务保存在红黑树中，按 virtual-runtime 排序。这样，virtual-runtime 最小的任务就被放在了树的最左侧，最大的任务就被放在树的最右端。随着任务的运行和切换，最左端的任务被不断取出，增加 virtual-runtime 值，然后重新插入红黑树，放在不同的位置。

#### CFS 中的优先级

在 CFS 策略下，优先级显得不那么重要了，高优先级的任务不一定能够抢占低优先级的任务，不过低优先级的任务，virtual-runtime 增长得更快。因此宏观上来看，如果一个任务的优先级更高，那么它得到的 CPU 比例也更多。

#### 组调度

CFS 提供的另一个功能就是组调度，因为并不是所有的任务都是平等的。任务从属于进程，如果一个进程为了并行处理数据而创建了大量的任务，超过了系统中其他进程创建的任务总数，那按照朴素的 CFS 调度，这个进程将可以占据机器上超过 50% 的 CPU 时间，这显然是不合理的。因此 CFS 提供了组调度，在同一个组里面的任务供用一个 virtual-runtime。

#### 调度器类

Linux 2.6 还提出了调度器类（scheduling class）这个概念，每个任务都属于一个调度器类，表示这个任务应该用哪一种策略进行调度。前面说过，CFS 策略下，任务的优先级只能决定 virtual-runtime 的增长速度，所以这样的调度策略必然不是实时的。但 Linux 仍然支持实时进程，正是通过调度器类实现的。

调度器类就像面向对象设计中的多态，首先我们定义调度器需要实现的功能（接口），也就是一堆函数，然后把所有需要实现的函数以函数指针的形式放在一个结构体里面，这个结构体就成了调度器类的类型。每一个具体的调度器类，就是一个这样的结构体对象（实现），所有的函数指针成员都被设置了取值，指向自己这个调度器类的私有实现。

Linux 实现了 rt、fair、idle 三个调度器类，这三个调度器类组成一个单链表。由于每个任务都属于一个调度器类，因此我们需要对这个任务执行相关调度操作时，只需要通过函数指针调用通用的函数即可。

### FreeBSD ULE 调度器

这是 FreeBSD 中使用的调度器，ULE 这个名字并没有什么特殊含义，只因为它是单词“schedule”的后三个字母，而源码中经常用缩写 `sched` 表示调度器。

在 FreeBSD 中，调度器分为两个层次。底层的调度器在每次就绪队列发生变更的时候执行，因为此时最高优先级的任务可能改变。