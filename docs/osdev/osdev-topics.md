---
title: "OSDev相关话题"
---

### Stack Tracer

stacktrace是调试过程中非常好用的工具，可以清楚地看到出错代码的调用过程。

在x86/AMD64架构下，堆栈的结构比较固定，因此通过rbp寄存器就可以不断访问外层的栈帧，从而读出每一层函数调用的返回地址。

然而，仅仅读出返回地址还不够，如果能直接打印出函数名就更加方便了。要打印出函数名，首先需要有符号表。ELF格式的内核镜像是自带符号表的（当然strip之后会去掉）

- - -

---
title: "任务管理与调度"
---

多任务是现代操作系统的标配，在Wheel中，我们首先实现内核态的多任务，然后再给每个任务增加用户态的支持，就像VxWorks的技术路线一样。

任务（Task）是一个抽象的概念，封装了当前正在执行的程序和CPU状态信息，可以认为一个任务就是一个执行流。内核态任务共享地址空间，因此多个任务可以执行相同的代码，但只要不同任务的上下文（context）不冲突，执行相同的代码就不会有问题。

除了封装执行流，任务还能够实现调度。也就是根据任务的优先级和状态，合理分配CPU计算资源。调度算法也是很关键的问题，但是Wheel采取了最简单的设计——固定优先级的抢占式调度。这种调度算法非常类似VxWorks，只是有一个区别：Wheel中的每个任务都具有CPU亲和性，也就是只能在一个CPU上运行。这个约束保证了任务不会在多个CPU之间迁移，可以让调度算法更简单。

### 就绪队列

就绪队列是就绪状态任务的容器，所有TS_READY状态的任务都位于这个队列中。就绪队列是一个CPU-local变量，也就是每个CPU都有一个就绪队列。Wheel要求每个任务都有CPU亲和性，也就不存在全局的就绪队列。

对每个CPU来说，就绪队列实际上是很多个双向链表，系统中的每一个优先级都对应一个双向链表。此外，就绪队列数据结构中还有一个`priorities`位图，表示特定优先级是否存在就绪状态的任务。通过这个位图，可以快速找到当前最高的优先级。根据我们的调度策略，优先级最高的任务运行，因此根据`priorities`字段找到目标双链表之后，链表的头节点就是接下来要运行的任务。

### `tid_prev`和`tid_next`

很多系统中都有一个`current_tid`变量，表示当前正在运行的任务。但是在Wheel中，我们使用两个变量。这种方法有些类似双缓冲，好处是在任务切换过程中比较符合逻辑。

如果没有发生任务切换，那么`tid_prev`和`tid_next`指向的是相同的任务，也就是目前正在运行的。如果发生了任务切换，需要从任务A切换到任务B，那么会首先将`tid_next`置为B，并调用`task_switch`触发一次任务切换。在汇编代码中，切换任务栈，并将`tid_prev`设为`tid_next`的值。如果设置了`tid_next`还没有进行切换，此时代码需要获取当前正在运行的任务，便可以从`tid_prev`中读取，因为`tid_prev`始终表示**当前**正在运行的任务。

### 任务状态

每个task都有状态，状态并不是互斥的，而是不同的状态位（例如TS_PEND、TS_DELAY、TS_SUSPEND）。当所有状态位都是0，也就是`tid->state == 0`时，表示这个任务是可运行的，也就是TS_READY。

当任务的状态转换时，我们只关心0与非0的切换，因为这两种状态分别是可执行与不可执行。任务状态的切换是很常见的，例如获取信号量失败，等待消息队列中的数据，以及主动进入休眠状态。而且，触发任务状态转换的也不一定是目标任务本身，可能是其他任务，甚至可能是ISR这些非任务代码。在多核环境下，一个CPU还有可能改变另一个CPU上任务的状态。

任务的状态转换之后，接下来要做的就是修改就绪队列。将任务放入就绪队列，或者从就绪队列中移除。这一步还有可能改变当前正在运行的任务。如果一个高优先级的任务变为就绪状态，比目标CPU上正在运行的任务的优先级更高，那么就会抢占目标CPU上正在运行的任务；如果某个正在运行的任务不再是就绪状态，那么需要从目标CPU的就绪队列中挑选出一个新的任务执行。

### 竞争情况分析

多核调度的一个关键就是防止数据竞争，Wheel针对可能发生竞争的数据结构全都使用自旋锁保护。下面以`task_stop`过程为例，分析可能的竞争情况。

- 首先关闭当前CPU的中断。因为任务状态切换可以发生在ISR中，为了避免自身CPU上任务代码与ISR代码之间的竞争，必须关闭中断，否则可能发生死锁。至于当前CPU与其他CPU的竞争，则依靠后面的自旋锁保护。
- 获取目标task的自旋锁。因为我们即将操作任务状态，也就是修改TCB，那么需要首先获取自旋锁。只有获取自旋锁之后，才能保证我们对目标task是独占状态，可以任意修改其内容。
- 改变task的状态，如果发现task已经不是ready状态，那么直接释放所有锁退出。
- 如果task之前是TS_READY状态，也就是这个任务变为不可执行的状态，那么我们需要修改就绪队列。
- 获取就绪队列的自旋锁，将任务从就绪队列的双链表中删除。
- 如果刚刚移出就绪队列的任务是`tid_next`，也就是之前被选出运行的任务，那么我们需要再找出一个新的任务，顶替之。
- 一切操作完成，释放就绪队列的自旋锁，释放任务的自旋锁，释放CPU的中断。

为了防止出现死锁，一定要按照统一的顺序获取/释放自旋锁。上面的例子中，只有两个自旋锁，但是很少有直接调用task_stop停止一个任务的，大部分都是在各种通信机制中改变任务状态，例如信号量。获取一个信号量时，锁的获取情况是这样的：

- 获取信号量的自旋锁。
- 判断是否得到该信号量，如果成功则释放锁退出，如果没有得到信号量则继续。
- 关闭当前CPU的中断，获取当前任务的自旋锁。
- 将当前任务放入信号量的阻塞队列中，将当前任务设为PEND状态。（与`task_stop`的情况相同）
- 任务状态变为PEND之后，释放信号量的自旋锁。

与单纯的`task_stop`情况相比，信号量的情况多了一个自旋锁。然而有一个关键问题，那就是信号量自旋锁的释放是在当前任务进入阻塞状态之后执行的。如果任务已经不运行了，那么释放信号量这个动作也无法执行。

我们使用`tid_prev`和`tid_next`这两个变量的好处之一，就是不用立即切换任务。更新了变量`tid_next`之后，就可以认为我们已经成功切换了任务，哪怕目前的任务仍然在运行。因为调度并不是真正地切换任务，而是确定将要切换到哪一个任务。在多核系统上，有可能一个CPU上发生很多次任务调度，如果每次调度都会有一个任务切换，那么CPU就会频繁地在各个任务之间切来切去，浪费大量的计算资源。

在确定`tid_next`之后单独调用`task_switch`切换任务，相当于Lazy策略，这可以尽最大可能的避免无用切换。而且好处就是，在我们执行可`task_stop`之后，还可以执行一些收尾工作，例如释放信号量的自旋锁。

因此在Wheel中，函数`task_stop`和`task_cont`仅仅负责操作TCB、就绪队列，以及`tid_next`变量，并不负责切换任务。外层函数调用`task_stop`和`task_cont`完成了调度操作之后，再手动调用`task_switch`或发送IPI，触发任务切换操作。